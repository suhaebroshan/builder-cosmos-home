import React, { useEffect, useRef, useCallback, useState } from 'react'\nimport { usePerformanceManager } from '@/hooks/usePerformanceManager'\nimport { useDeviceDetection } from '@/hooks/useDeviceDetection'\n\ninterface Particle {\n  x: number\n  y: number\n  vx: number\n  vy: number\n  size: number\n  opacity: number\n  life: number\n  maxLife: number\n  color: string\n}\n\ninterface OptimizedLiveWallpaperProps {\n  className?: string\n}\n\nexport const OptimizedLiveWallpaper: React.FC<OptimizedLiveWallpaperProps> = ({ \n  className = \"\" \n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const animationRef = useRef<number>()\n  const particlesRef = useRef<Particle[]>([])\n  const lastFrameTime = useRef(0)\n  const fpsCounter = useRef(0)\n  const lastFpsUpdate = useRef(0)\n  const [isVisible, setIsVisible] = useState(true)\n  \n  const { profile, performanceStats } = usePerformanceManager()\n  const { deviceInfo } = useDeviceDetection()\n\n  // Performance-based configuration\n  const getConfig = useCallback(() => {\n    const baseConfig = {\n      particleCount: profile.particleCount,\n      maxParticles: profile.particleCount * 2,\n      targetFPS: profile.frameRateTarget,\n      enableBlur: profile.blurIntensity > 0,\n      enableGlow: profile.enableAdvancedEffects,\n      animationSpeed: 1,\n      cleanup: profile.memoryOptimization,\n    }\n\n    // Adjust for battery\n    if (performanceStats.isLowPowerMode) {\n      return {\n        ...baseConfig,\n        particleCount: Math.max(baseConfig.particleCount / 4, 5),\n        targetFPS: 30,\n        enableBlur: false,\n        enableGlow: false,\n        animationSpeed: 0.5,\n      }\n    }\n\n    // Adjust for performance\n    if (performanceStats.fps < 30) {\n      return {\n        ...baseConfig,\n        particleCount: Math.max(baseConfig.particleCount / 2, 10),\n        enableBlur: false,\n        enableGlow: false,\n      }\n    }\n\n    return baseConfig\n  }, [profile, performanceStats])\n\n  // Visibility observer for performance\n  useEffect(() => {\n    if (!profile.enableWallpaperAnimations) {\n      setIsVisible(false)\n      return\n    }\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsVisible(entry.isIntersecting)\n      },\n      { threshold: 0.1 }\n    )\n\n    const canvas = canvasRef.current\n    if (canvas) {\n      observer.observe(canvas)\n    }\n\n    return () => {\n      if (canvas) {\n        observer.unobserve(canvas)\n      }\n    }\n  }, [profile.enableWallpaperAnimations])\n\n  // Particle creation\n  const createParticle = useCallback((canvas: HTMLCanvasElement): Particle => {\n    const colors = [\n      'rgba(139, 92, 246, ', // purple-500\n      'rgba(168, 85, 247, ', // purple-400\n      'rgba(59, 130, 246, ',  // blue-500\n      'rgba(147, 51, 234, ',  // purple-600\n      'rgba(79, 70, 229, ',   // indigo-600\n    ]\n\n    return {\n      x: Math.random() * canvas.width,\n      y: canvas.height + 10,\n      vx: (Math.random() - 0.5) * 2,\n      vy: -Math.random() * 3 - 1,\n      size: Math.random() * 3 + 1,\n      opacity: Math.random() * 0.8 + 0.2,\n      life: 0,\n      maxLife: Math.random() * 200 + 100,\n      color: colors[Math.floor(Math.random() * colors.length)],\n    }\n  }, [])\n\n  // Particle update\n  const updateParticle = useCallback((particle: Particle, deltaTime: number, config: any): boolean => {\n    particle.life += deltaTime * config.animationSpeed\n    particle.x += particle.vx * deltaTime * 0.1 * config.animationSpeed\n    particle.y += particle.vy * deltaTime * 0.1 * config.animationSpeed\n\n    // Fade out over lifetime\n    const lifeFactor = 1 - (particle.life / particle.maxLife)\n    particle.opacity = lifeFactor * 0.8\n\n    // Apply physics\n    particle.vy += 0.01 * deltaTime // gravity\n    particle.vx *= 0.99 // air resistance\n\n    return particle.life < particle.maxLife && particle.y > -50\n  }, [])\n\n  // Render function with performance optimizations\n  const render = useCallback((canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => {\n    const config = getConfig()\n    \n    // Clear canvas efficiently\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n    // Set composite operation for performance\n    ctx.globalCompositeOperation = 'normal'\n\n    particlesRef.current.forEach((particle, index) => {\n      if (!particle) return\n\n      ctx.beginPath()\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2)\n      \n      // Performance-based rendering\n      if (config.enableGlow && profile.enableAdvancedEffects) {\n        // Glow effect for high performance\n        const gradient = ctx.createRadialGradient(\n          particle.x, particle.y, 0,\n          particle.x, particle.y, particle.size * 3\n        )\n        gradient.addColorStop(0, particle.color + particle.opacity + ')')\n        gradient.addColorStop(0.5, particle.color + (particle.opacity * 0.5) + ')')\n        gradient.addColorStop(1, particle.color + '0)')\n        ctx.fillStyle = gradient\n      } else {\n        // Simple fill for performance\n        ctx.fillStyle = particle.color + particle.opacity + ')'\n      }\n      \n      ctx.fill()\n    })\n\n    // Add subtle background gradient for depth\n    if (profile.enableAdvancedEffects) {\n      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height)\n      gradient.addColorStop(0, 'rgba(79, 70, 229, 0.02)')\n      gradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.01)')\n      gradient.addColorStop(1, 'rgba(168, 85, 247, 0.02)')\n      \n      ctx.fillStyle = gradient\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\n    }\n  }, [getConfig, profile.enableAdvancedEffects])\n\n  // Main animation loop with FPS control\n  const animate = useCallback((currentTime: number) => {\n    if (!isVisible || !profile.enableWallpaperAnimations) {\n      animationRef.current = requestAnimationFrame(animate)\n      return\n    }\n\n    const canvas = canvasRef.current\n    const ctx = canvas?.getContext('2d')\n    if (!canvas || !ctx) {\n      animationRef.current = requestAnimationFrame(animate)\n      return\n    }\n\n    const config = getConfig()\n    const targetFrameTime = 1000 / config.targetFPS\n    const deltaTime = currentTime - lastFrameTime.current\n\n    // Frame rate limiting\n    if (deltaTime < targetFrameTime) {\n      animationRef.current = requestAnimationFrame(animate)\n      return\n    }\n\n    lastFrameTime.current = currentTime\n\n    // FPS monitoring\n    fpsCounter.current++\n    if (currentTime - lastFpsUpdate.current >= 1000) {\n      lastFpsUpdate.current = currentTime\n      fpsCounter.current = 0\n    }\n\n    // Particle management\n    const particles = particlesRef.current\n    \n    // Update existing particles\n    for (let i = particles.length - 1; i >= 0; i--) {\n      const particle = particles[i]\n      if (!updateParticle(particle, deltaTime, config)) {\n        particles.splice(i, 1)\n      }\n    }\n\n    // Add new particles based on performance\n    if (particles.length < config.particleCount && Math.random() < 0.1) {\n      particles.push(createParticle(canvas))\n    }\n\n    // Memory cleanup\n    if (config.cleanup && particles.length > config.maxParticles) {\n      particles.splice(0, particles.length - config.particleCount)\n    }\n\n    // Render\n    render(canvas, ctx)\n\n    animationRef.current = requestAnimationFrame(animate)\n  }, [isVisible, profile.enableWallpaperAnimations, getConfig, updateParticle, createParticle, render])\n\n  // Canvas setup and resize handling\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true, // Performance optimization\n    })\n    if (!ctx) return\n\n    const updateCanvasSize = () => {\n      const rect = canvas.getBoundingClientRect()\n      const dpr = profile.enableGPUAcceleration ? (window.devicePixelRatio || 1) : 1\n      \n      canvas.width = rect.width * dpr\n      canvas.height = rect.height * dpr\n      \n      ctx.scale(dpr, dpr)\n      canvas.style.width = rect.width + 'px'\n      canvas.style.height = rect.height + 'px'\n    }\n\n    updateCanvasSize()\n\n    const resizeObserver = new ResizeObserver(updateCanvasSize)\n    resizeObserver.observe(canvas)\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [profile.enableGPUAcceleration])\n\n  // Start animation\n  useEffect(() => {\n    if (profile.enableWallpaperAnimations && isVisible) {\n      animationRef.current = requestAnimationFrame(animate)\n    }\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n    }\n  }, [animate, profile.enableWallpaperAnimations, isVisible])\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n      particlesRef.current = []\n    }\n  }, [])\n\n  // Memory cleanup listener\n  useEffect(() => {\n    const handleMemoryCleanup = () => {\n      particlesRef.current = []\n    }\n\n    window.addEventListener('nyx:cleanup-memory', handleMemoryCleanup)\n    return () => window.removeEventListener('nyx:cleanup-memory', handleMemoryCleanup)\n  }, [])\n\n  if (!profile.enableWallpaperAnimations) {\n    return (\n      <div \n        className={`fixed inset-0 bg-gradient-to-br from-slate-900 via-purple-950 to-slate-900 ${className}`}\n        style={{ zIndex: -1 }}\n      />\n    )\n  }\n\n  return (\n    <>\n      {/* Static background for when canvas is disabled */}\n      <div \n        className={`fixed inset-0 bg-gradient-to-br from-slate-900 via-purple-950 to-slate-900 ${className}`}\n        style={{ zIndex: -1 }}\n      />\n      \n      {/* Animated canvas overlay */}\n      <canvas\n        ref={canvasRef}\n        className={`fixed inset-0 pointer-events-none ${className}`}\n        style={{ \n          zIndex: -1,\n          opacity: isVisible ? 1 : 0,\n          transition: 'opacity 0.5s ease',\n          willChange: profile.enableGPUAcceleration ? 'transform' : 'auto',\n        }}\n      />\n    </>\n  )\n}"